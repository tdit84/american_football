<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Responsive viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Football Kick Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-y: auto;
      background: #087E3B; /* Field green */
      height: 100%;
      width: 100%;
    }
    /* Container for the game canvas and SVG overlay */
    #gameContainer {
      position: relative;
      width: 100%;
      min-height: 100vh;
      background: #087E3B;
    }
    /* The Matter.js game canvas */
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      display: block;
    }
    /* SVG overlay for field markings */
    #fieldOverlay {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    /* New Game button styling */
    #newGameButton {
      position: absolute;
      display: none;
      font-size: 32px;
      padding: 15px 30px;
      background: rgba(0,0,0,0.6);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 3;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <!-- SVG overlay with field markings -->
    <svg id="fieldOverlay" viewBox="0 0 800 600" preserveAspectRatio="none">
      <!-- Left endzone boundary -->
      <line x1="80" y1="0" x2="80" y2="600" stroke="white" stroke-width="2"/>
      <!-- Right endzone boundary -->
      <line x1="720" y1="0" x2="720" y2="600" stroke="white" stroke-width="2"/>
      <!-- Yard lines every 64 units between x=80 and 720 -->
      <line x1="144" y1="0" x2="144" y2="600" stroke="white" stroke-width="2"/>
      <line x1="208" y1="0" x2="208" y2="600" stroke="white" stroke-width="2"/>
      <line x1="272" y1="0" x2="272" y2="600" stroke="white" stroke-width="2"/>
      <line x1="336" y1="0" x2="336" y2="600" stroke="white" stroke-width="2"/>
      <line x1="400" y1="0" x2="400" y2="600" stroke="white" stroke-width="2"/>
      <line x1="464" y1="0" x2="464" y2="600" stroke="white" stroke-width="2"/>
      <line x1="528" y1="0" x2="528" y2="600" stroke="white" stroke-width="2"/>
      <line x1="592" y1="0" x2="592" y2="600" stroke="white" stroke-width="2"/>
      <line x1="656" y1="0" x2="656" y2="600" stroke="white" stroke-width="2"/>
      <!-- Top yard markers -->
      <text x="144" y="30" fill="white" font-size="24" text-anchor="middle">10</text>
      <text x="208" y="30" fill="white" font-size="24" text-anchor="middle">20</text>
      <text x="272" y="30" fill="white" font-size="24" text-anchor="middle">30</text>
      <text x="336" y="30" fill="white" font-size="24" text-anchor="middle">40</text>
      <text x="400" y="30" fill="white" font-size="24" text-anchor="middle">50</text>
      <text x="464" y="30" fill="white" font-size="24" text-anchor="middle">60</text>
      <text x="528" y="30" fill="white" font-size="24" text-anchor="middle">70</text>
      <text x="592" y="30" fill="white" font-size="24" text-anchor="middle">80</text>
      <text x="656" y="30" fill="white" font-size="24" text-anchor="middle">90</text>
      <!-- Bottom yard markers -->
      <text x="144" y="570" fill="white" font-size="24" text-anchor="middle">10</text>
      <text x="208" y="570" fill="white" font-size="24" text-anchor="middle">20</text>
      <text x="272" y="570" fill="white" font-size="24" text-anchor="middle">30</text>
      <text x="336" y="570" fill="white" font-size="24" text-anchor="middle">40</text>
      <text x="400" y="570" fill="white" font-size="24" text-anchor="middle">50</text>
      <text x="464" y="570" fill="white" font-size="24" text-anchor="middle">60</text>
      <text x="528" y="570" fill="white" font-size="24" text-anchor="middle">70</text>
      <text x="592" y="570" fill="white" font-size="24" text-anchor="middle">80</text>
      <text x="656" y="570" fill="white" font-size="24" text-anchor="middle">90</text>
    </svg>
    <button id="newGameButton">New Game</button>
  </div>
  <!-- Include Matter.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // --- Responsive Resize Function ---
    // Resize the gameCanvas and the SVG overlay together.
    function resizeCanvases() {
      const gameCanvas = document.getElementById('gameCanvas');
      const overlay = document.getElementById('fieldOverlay');
      const container = document.getElementById('gameContainer');
      const winW = window.innerWidth;
      const winH = window.innerHeight;
      const gameW = 800, gameH = 600;
      let scale;
      if (winW > winH) {
        // Landscape: use full viewport height.
        scale = winH / gameH;
        gameCanvas.style.width = (gameW * scale) + "px";
        gameCanvas.style.height = (gameH * scale) + "px";
        gameCanvas.style.marginLeft = ((winW - gameW * scale) / 2) + "px";
        gameCanvas.style.marginTop = "0px";
        container.style.height = (gameH * scale) + "px";
        overlay.style.width = gameCanvas.style.width;
        overlay.style.height = gameCanvas.style.height;
        overlay.style.marginLeft = gameCanvas.style.marginLeft;
        overlay.style.marginTop = gameCanvas.style.marginTop;
      } else {
        // Portrait: use full viewport width.
        scale = winW / gameW;
        gameCanvas.style.width = (gameW * scale) + "px";
        gameCanvas.style.height = (gameH * scale) + "px";
        gameCanvas.style.marginTop = ((winH - gameH * scale) / 2) + "px";
        gameCanvas.style.marginLeft = "0px";
        container.style.height = winH + "px";
        overlay.style.width = gameCanvas.style.width;
        overlay.style.height = gameCanvas.style.height;
        overlay.style.marginTop = gameCanvas.style.marginTop;
        overlay.style.marginLeft = "0px";
      }
      gameCanvas.dataset.scale = scale;
    }
    window.addEventListener('resize', resizeCanvases);
    resizeCanvases();
    
    // --- Adjust getCanvasPos to account for scaling ---
    function getCanvasPos(canvas, evt) {
      const rect = canvas.getBoundingClientRect();
      const scale = parseFloat(canvas.dataset.scale) || 1;
      return {
        x: (evt.clientX - rect.left) / scale,
        y: (evt.clientY - rect.top) / scale
      };
    }
    
    // --- Matter.js Setup ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Body = Matter.Body,
          Events = Matter.Events;
    
    const engine = Engine.create();
    const world = engine.world;
    
    const gameCanvas = document.getElementById('gameCanvas');
    // Set the Matter.js renderer background to transparent so the SVG shows.
    const render = Render.create({
      canvas: gameCanvas,
      engine: engine,
      options: {
        width: 800,
        height: 600,
        wireframes: false,
        background: "transparent"
      }
    });
    Render.run(render);
    
    const runner = Runner.create();
    Runner.run(runner, engine);
    
    // --- Global Game Variables ---
    let score = 0;
    let kickCount = 0;
    let goalMessage = "";
    let timeLeft = 30;
    let gameActive = true;
    
    // Countdown timer.
    const timerInterval = setInterval(() => {
      if (gameActive) {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          gameActive = false;
          const btn = document.getElementById('newGameButton');
          btn.style.display = "block";
          btn.style.left = "50%";
          btn.style.top = "70%";
          btn.style.transform = "translate(-50%, -50%)";
        }
      }
    }, 1000);
    
    // New Game button functionality.
    const newGameButton = document.getElementById('newGameButton');
    newGameButton.addEventListener('click', () => {
      resetGame();
      newGameButton.style.display = "none";
    });
    
    // --- Create the Scene ---
    // Ground.
    const ground = Bodies.rectangle(400, 590, 810, 20, { 
      isStatic: true,
      render: { fillStyle: "#087E3B" }
    });
    Composite.add(world, ground);
    
    // Obstacles.
    const obstacle1 = Bodies.rectangle(400, 500, 100, 20, { 
      isStatic: true, 
      angle: Math.PI * 0.06, 
      render: { fillStyle: "#8B4513" },
      isObstacle: true,
      isOriginal: true
    });
    const obstacle2 = Bodies.rectangle(600, 400, 150, 20, { 
      isStatic: true, 
      angle: -Math.PI * 0.1, 
      render: { fillStyle: "#8B4513" },
      isObstacle: true,
      isOriginal: true
    });
    Composite.add(world, [obstacle1, obstacle2]);
    
    // Goal area.
    const goal = Bodies.rectangle(750, 500, 80, 200, { 
      isStatic: true, 
      isSensor: true, 
      render: { fillStyle: "rgba(0,0,0,0)" }
    });
    Composite.add(world, goal);
    
    // Football.
    const ballRadius = 20;
    const ball = Bodies.circle(150, 500, ballRadius, { 
      restitution: 0.6, 
      density: 0.004,
      render: { fillStyle: "#ffffff" }
    });
    Composite.add(world, ball);
    
    // --- Custom Rendering for Game Info and Drag Indicator ---
    Events.on(render, 'afterRender', function() {
      const context = render.context;
      
      // Draw the football emoji on the ball.
      context.font = "40px serif";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText("üèà", ball.position.x, ball.position.y);
      
      if (gameActive && isDragging && dragStart && dragCurrent) {
        context.strokeStyle = "red";
        context.lineWidth = 3;
        context.beginPath();
        context.moveTo(ball.position.x, ball.position.y);
        context.lineTo(dragCurrent.x, dragCurrent.y);
        context.stroke();
        context.font = "75px serif";
        context.fillText("üëü", ball.position.x - 50, ball.position.y);
      }
      
      if (gameActive) {
        // Draw in-game score and time in large white text near the bottom.
        context.font = "28px sans-serif";
        context.fillStyle = "white";
        context.textAlign = "left";
        context.fillText("Score: " + score, 10, 550);
        context.textAlign = "right";
        context.fillText("Time: " + timeLeft, 790, 550);
      } else {
        // Draw final score centered.
        context.font = "64px sans-serif";
        context.fillStyle = "white";
        context.textAlign = "center";
        context.fillText("Final Score: " + score, 400, 300);
      }
    });
    
    // --- Interaction for the Kick ---
    let isDragging = false;
    let dragStart = null;
    let dragCurrent = null;
    
    gameCanvas.addEventListener('mousedown', function(evt) {
      if (!gameActive) return;
      const pos = getCanvasPos(gameCanvas, evt);
      if (Math.hypot(pos.x - ball.position.x, pos.y - ball.position.y) <= ballRadius) {
        isDragging = true;
        dragStart = pos;
        dragCurrent = pos;
      }
    });
    
    gameCanvas.addEventListener('mousemove', function(evt) {
      if (!gameActive) return;
      if (isDragging) {
        dragCurrent = getCanvasPos(gameCanvas, evt);
      }
    });
    
    gameCanvas.addEventListener('mouseup', function(evt) {
      if (!gameActive) return;
      if (isDragging) {
        isDragging = false;
        const dragEnd = getCanvasPos(gameCanvas, evt);
        const forceMagnitude = 0.005;
        const force = {
          x: (dragStart.x - dragEnd.x) * forceMagnitude,
          y: (dragStart.y - dragEnd.y) * forceMagnitude
        };
        Body.applyForce(ball, ball.position, force);
        kickCount++;
        dragStart = null;
        dragCurrent = null;
      }
    });
    
    gameCanvas.addEventListener('touchstart', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      const touch = evt.touches[0];
      const pos = getCanvasPos(gameCanvas, touch);
      if (Math.hypot(pos.x - ball.position.x, pos.y - ball.position.y) <= ballRadius) {
        isDragging = true;
        dragStart = pos;
        dragCurrent = pos;
      }
    });
    
    gameCanvas.addEventListener('touchmove', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      if (isDragging) {
        const touch = evt.touches[0];
        dragCurrent = getCanvasPos(gameCanvas, touch);
      }
    });
    
    gameCanvas.addEventListener('touchend', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      if (isDragging) {
        isDragging = false;
        const touch = evt.changedTouches[0];
        const dragEnd = getCanvasPos(gameCanvas, touch);
        const forceMagnitude = 0.005;
        const force = {
          x: (dragStart.x - dragEnd.x) * forceMagnitude,
          y: (dragStart.y - dragEnd.y) * forceMagnitude
        };
        Body.applyForce(ball, ball.position, force);
        kickCount++;
        dragStart = null;
        dragCurrent = null;
      }
    });
    
    // --- Collision Events and Reset Functions ---
    Events.on(engine, 'collisionStart', function(event) {
      if (!gameActive) return;
      event.pairs.forEach(pair => {
        if ((pair.bodyA === ball && pair.bodyB === goal) ||
            (pair.bodyB === ball && pair.bodyA === goal)) {
          let roundScore = 100 - ((kickCount - 1) * 10);
          if (roundScore < 0) roundScore = 0;
          score += roundScore;
          goalMessage = "TOUCHDOWN!";
          setTimeout(() => { goalMessage = ""; }, 2000);
          resetRound();
          // Create a new obstacle.
          let newX, newY;
          if (Math.random() < 0.5) {
            newX = Math.random() * (650 - 300) + 300;
            newY = Math.random() * (580 - 550) + 550;
          } else {
            newX = Math.random() * (650 - 300) + 300;
            newY = Math.random() * (400 - 200) + 200;
          }
          const newObstacle = Bodies.rectangle(newX, newY, 100, 20, {
            isStatic: true,
            angle: Math.PI * (Math.random() * 0.3 - 0.15),
            render: { fillStyle: "#8B4513" },
            isObstacle: true,
            isNewObstacle: true
          });
          Composite.add(world, newObstacle);
        }
      });
    });
    
    Events.on(engine, 'collisionStart', function(event) {
      if (!gameActive) return;
      event.pairs.forEach(pair => {
        if ((pair.bodyA === ball && pair.bodyB.isObstacle) ||
            (pair.bodyB === ball && pair.bodyA.isObstacle)) {
          score = Math.max(score - 50, 0);
        }
      });
    });
    
    Events.on(engine, 'afterUpdate', function() {
      if (!gameActive) return;
      if (ball.position.x < 0 || ball.position.x > render.options.width) {
        alert("Ball went off screen. Game over.");
        resetGame();
      }
    });
    
    function resetRound() {
      Body.setPosition(ball, { x: 150, y: 500 });
      Body.setVelocity(ball, { x: 0, y: 0 });
      kickCount = 0;
    }
    
    function resetGame() {
      const allBodies = Composite.allBodies(world);
      allBodies.forEach(body => {
        if (!body.isOriginal && body.isObstacle) {
          Composite.remove(world, body);
        }
      });
      score = 0;
      timeLeft = 30;
      gameActive = true;
      resetRound();
    }
    
  </script>
</body>
</html>
