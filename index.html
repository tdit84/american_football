<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <!-- Set the viewport for responsive design -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Emoji Football Kick Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow-y: auto; /* Allow scrolling if needed */
      background: #087E3B; /* Dark green typical for a football field */
      height: 100%;
      width: 100%;
    }
    /* Container for the canvas */
    #gameContainer {
      position: relative;
      width: 100%;
      min-height: 100vh;
      background: #087E3B;
    }
    /* The canvas has an internal resolution of 800x600 */
    #gameCanvas {
      display: block;
    }
    /* New Game button styling; initially hidden */
    #newGameButton {
      position: absolute;
      display: none;
      font-size: 32px;
      padding: 15px 30px;
      background: rgba(0,0,0,0.6);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="newGameButton">New Game</button>
  </div>
  <!-- Include Matter.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // --- Responsive Resize Function ---
    // Fixed game world: 800x600.
    // In landscape, use full viewport height; in portrait, full viewport width.
    // The computed scale factor is stored on the canvas.
    function resizeCanvas() {
      const canvas = document.getElementById('gameCanvas');
      const container = document.getElementById('gameContainer');
      const winW = window.innerWidth;
      const winH = window.innerHeight;
      const gameW = 800, gameH = 600;
      let scale;
      if (winW > winH) {
        // Landscape: use full viewport height.
        scale = winH / gameH;
        canvas.style.width = (gameW * scale) + "px";
        canvas.style.height = (gameH * scale) + "px";
        canvas.style.marginLeft = ((winW - gameW * scale) / 2) + "px";
        canvas.style.marginTop = "0px";
        container.style.height = (gameH * scale) + "px";
      } else {
        // Portrait: use full viewport width.
        scale = winW / gameW;
        canvas.style.width = (gameW * scale) + "px";
        canvas.style.height = (gameH * scale) + "px";
        canvas.style.marginTop = ((winH - gameH * scale) / 2) + "px";
        canvas.style.marginLeft = "0px";
        container.style.height = winH + "px";
      }
      canvas.dataset.scale = scale;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // --- Adjust getCanvasPos to account for scaling ---
    function getCanvasPos(canvas, evt) {
      const rect = canvas.getBoundingClientRect();
      const scale = parseFloat(canvas.dataset.scale) || 1;
      return {
        x: (evt.clientX - rect.left) / scale,
        y: (evt.clientY - rect.top) / scale
      };
    }
    
    // --- Draw Field Markings in beforeRender ---
    // This draws the endzones, yard lines every 10 yards, and yard markers.
    Matter.Events.on(render, 'beforeRender', function() {
      const context = render.context;
      // Save context state.
      context.save();
      // Clear background (we set a field-green background in CSS, but we draw field lines here).
      // Draw left endzone.
      context.fillStyle = "#00338D"; // Blue endzone
      context.fillRect(0, 0, 80, 600);
      // Draw right endzone.
      context.fillStyle = "#CE1126"; // Red endzone
      context.fillRect(720, 0, 80, 600);
      // Draw main field background.
      context.fillStyle = "#087E3B";
      context.fillRect(80, 0, 640, 600);
      // Draw yard lines every 64 units in the main field (10-yard increments).
      context.strokeStyle = "white";
      context.lineWidth = 2;
      for (let n = 1; n < 10; n++) {
        let x = 80 + n * 64;
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, 600);
        context.stroke();
        // Draw yard marker at top.
        context.font = "24px sans-serif";
        context.fillStyle = "white";
        context.textAlign = "center";
        context.fillText(n*10, x, 30);
      }
      // Restore context state.
      context.restore();
    });
    
    // --- Matter.js Setup ---
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Body = Matter.Body,
          Events = Matter.Events;
    
    const engine = Engine.create();
    const world = engine.world;
    
    const canvas = document.getElementById('gameCanvas');
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: 800,
        height: 600,
        wireframes: false,
        background: "transparent" // We draw the field ourselves.
      }
    });
    Render.run(render);
    
    const runner = Runner.create();
    Runner.run(runner, engine);
    
    // --- Global Game Variables ---
    let score = 0;
    let kickCount = 0;
    let goalMessage = "";
    let timeLeft = 30;
    let gameActive = true;
    
    // Countdown timer.
    const timerInterval = setInterval(() => {
      if (gameActive) {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          gameActive = false;
          // Reposition the New Game button to below the final score.
          const btn = document.getElementById('newGameButton');
          btn.style.display = "block";
          btn.style.left = "50%";
          btn.style.top = "65%";
          btn.style.transform = "translate(-50%, -50%)";
        }
      }
    }, 1000);
    
    // New Game button functionality.
    const newGameButton = document.getElementById('newGameButton');
    newGameButton.addEventListener('click', () => {
      resetGame();
      newGameButton.style.display = "none";
    });
    
    // --- Create the Scene ---
    // Ground (turf field) ‚Äì although our field is drawn in beforeRender.
    const ground = Bodies.rectangle(400, 590, 810, 20, { 
      isStatic: true,
      render: { fillStyle: "#087E3B" }
    });
    Composite.add(world, ground);
    
    // Obstacles (defenders).
    const obstacle1 = Bodies.rectangle(400, 500, 100, 20, { 
      isStatic: true, 
      angle: Math.PI * 0.06, 
      render: { fillStyle: "#8B4513" },
      isObstacle: true,
      isOriginal: true
    });
    const obstacle2 = Bodies.rectangle(600, 400, 150, 20, { 
      isStatic: true, 
      angle: -Math.PI * 0.1, 
      render: { fillStyle: "#8B4513" },
      isObstacle: true,
      isOriginal: true
    });
    Composite.add(world, [obstacle1, obstacle2]);
    
    // Goal area.
    const goal = Bodies.rectangle(750, 500, 80, 200, { 
      isStatic: true, 
      isSensor: true, 
      render: { fillStyle: "rgba(0,0,0,0)" }
    });
    Composite.add(world, goal);
    
    // Football.
    const ballRadius = 20;
    const ball = Bodies.circle(150, 500, ballRadius, { 
      restitution: 0.6, 
      density: 0.004,
      render: { fillStyle: "#ffffff" }
    });
    Composite.add(world, ball);
    
    // --- Custom Rendering for Game Info ---
    Events.on(render, 'afterRender', function() {
      const context = render.context;
      
      // Draw the football emoji on the ball.
      context.font = "40px serif";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText("üèà", ball.position.x, ball.position.y);
      
      if (gameActive) {
        // Draw current score and time in large white text at the lower part of the field.
        context.font = "28px sans-serif";
        context.fillStyle = "white";
        context.textAlign = "left";
        context.fillText("Score: " + score, 10, 550);
        context.textAlign = "right";
        context.fillText("Time: " + timeLeft, 790, 550);
      } else {
        // Draw final score centered on the screen.
        context.font = "64px sans-serif";
        context.fillStyle = "white";
        context.textAlign = "center";
        context.fillText("Final Score: " + score, 400, 300);
      }
    });
    
    // --- Interaction for the Kick ---
    let isDragging = false;
    let dragStart = null;
    let dragCurrent = null;
    
    canvas.addEventListener('mousedown', function(evt) {
      if (!gameActive) return;
      const pos = getCanvasPos(canvas, evt);
      if (Math.hypot(pos.x - ball.position.x, pos.y - ball.position.y) <= ballRadius) {
        isDragging = true;
        dragStart = pos;
        dragCurrent = pos;
      }
    });
    
    canvas.addEventListener('mousemove', function(evt) {
      if (!gameActive) return;
      if (isDragging) {
        dragCurrent = getCanvasPos(canvas, evt);
      }
    });
    
    canvas.addEventListener('mouseup', function(evt) {
      if (!gameActive) return;
      if (isDragging) {
        isDragging = false;
        const dragEnd = getCanvasPos(canvas, evt);
        const forceMagnitude = 0.005;
        const force = {
          x: (dragStart.x - dragEnd.x) * forceMagnitude,
          y: (dragStart.y - dragEnd.y) * forceMagnitude
        };
        Body.applyForce(ball, ball.position, force);
        kickCount++;
        dragStart = null;
        dragCurrent = null;
      }
    });
    
    canvas.addEventListener('touchstart', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      const touch = evt.touches[0];
      const pos = getCanvasPos(canvas, touch);
      if (Math.hypot(pos.x - ball.position.x, pos.y - ball.position.y) <= ballRadius) {
        isDragging = true;
        dragStart = pos;
        dragCurrent = pos;
      }
    });
    
    canvas.addEventListener('touchmove', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      if (isDragging) {
        const touch = evt.touches[0];
        dragCurrent = getCanvasPos(canvas, touch);
      }
    });
    
    canvas.addEventListener('touchend', function(evt) {
      if (!gameActive) return;
      evt.preventDefault();
      if (isDragging) {
        isDragging = false;
        const touch = evt.changedTouches[0];
        const dragEnd = getCanvasPos(canvas, touch);
        const forceMagnitude = 0.005;
        const force = {
          x: (dragStart.x - dragEnd.x) * forceMagnitude,
          y: (dragStart.y - dragEnd.y) * forceMagnitude
        };
        Body.applyForce(ball, ball.position, force);
        kickCount++;
        dragStart = null;
        dragCurrent = null;
      }
    });
    
    // --- Collision Events and Reset Functions ---
    Events.on(engine, 'collisionStart', function(event) {
      if (!gameActive) return;
      event.pairs.forEach(pair => {
        if ((pair.bodyA === ball && pair.bodyB === goal) ||
            (pair.bodyB === ball && pair.bodyA === goal)) {
          let roundScore = 100 - ((kickCount - 1) * 10);
          if (roundScore < 0) roundScore = 0;
          score += roundScore;
          goalMessage = "TOUCHDOWN!";
          setTimeout(() => { goalMessage = ""; }, 2000);
          resetRound();
          // Create a new obstacle at a random location.
          let newX, newY;
          if (Math.random() < 0.5) {
            newX = Math.random() * (650 - 300) + 300;
            newY = Math.random() * (580 - 550) + 550;
          } else {
            newX = Math.random() * (650 - 300) + 300;
            newY = Math.random() * (400 - 200) + 200;
          }
          const newObstacle = Bodies.rectangle(newX, newY, 100, 20, {
            isStatic: true,
            angle: Math.PI * (Math.random() * 0.3 - 0.15),
            render: { fillStyle: "#8B4513" },
            isObstacle: true,
            isNewObstacle: true
          });
          Composite.add(world, newObstacle);
        }
      });
    });
    
    Events.on(engine, 'collisionStart', function(event) {
      if (!gameActive) return;
      event.pairs.forEach(pair => {
        if ((pair.bodyA === ball && pair.bodyB.isObstacle) ||
            (pair.bodyB === ball && pair.bodyA.isObstacle)) {
          score = Math.max(score - 50, 0);
        }
      });
    });
    
    Events.on(engine, 'afterUpdate', function() {
      if (!gameActive) return;
      if (ball.position.x < 0 || ball.position.x > render.options.width) {
        alert("Ball went off screen. Game over.");
        resetGame();
      }
    });
    
    function resetRound() {
      Body.setPosition(ball, { x: 150, y: 500 });
      Body.setVelocity(ball, { x: 0, y: 0 });
      kickCount = 0;
    }
    
    function resetGame() {
      const allBodies = Composite.allBodies(world);
      allBodies.forEach(body => {
        if (!body.isOriginal && body.isObstacle) {
          Composite.remove(world, body);
        }
      });
      score = 0;
      timeLeft = 30;
      gameActive = true;
      resetRound();
    }
    
  </script>
</body>
</html>
